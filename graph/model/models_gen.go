// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
)

type Contributor struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

type ContributorFilter struct {
	ID   *string `json:"id"`
	Name *string `json:"name"`
}

// Episode (i.e., TV Show) details.
type Episode struct {
	Series  *Series `json:"series"`
	Season  int     `json:"season"`
	Episode int     `json:"episode"`
	Video   *Video  `json:"video"`
}

type EpisodeFilter struct {
	Series  *SeriesFilter `json:"series"`
	Season  *int          `json:"season"`
	Episode *int          `json:"episode"`
}

type GeometryFilter struct {
	Width  *int `json:"width"`
	Height *int `json:"height"`
}

// Slice of identifiable objects.
type Paginate struct {
	// Maximum length of list returned (optional).
	// If omitted, return remaining objects.
	First *int `json:"first"`
	// Return objects after this identified one.
	// Requires a stable list.
	After *string `json:"after"`
}

type Quality struct {
	VideoCodec      VideoCodec       `json:"videoCodec"`
	Resolution      string           `json:"resolution"`
	TranscodeBudget *TranscodeBudget `json:"transcodeBudget"`
}

type QualityFilter struct {
	VideoCodec *VideoCodec `json:"videoCodec"`
	Resolution *string     `json:"resolution"`
}

// Video rendition details.
type Rendition struct {
	// Rendition identity.
	// Currently a hash of local path.
	ID string `json:"id"`
	// Video rendition download URL.
	URL string `json:"url"`
	// Cut (optional).
	// Omit wrapping parenthesis.
	// If absent, "theatrical" is implied.
	Cut *string `json:"cut"`
	// Quality details.
	Quality *Quality `json:"quality"`
	// Length of video, in minutes.
	Duration *int `json:"duration"`
	// Is video high definition, i.e., 1080p resolution?
	// Currently derived from the mp4 moov.udta.meta.ilst.hdvd.data atom.
	IsHd *bool `json:"isHD"`
	// Size of the video, in bytes.
	Size int `json:"size"`
}

// Series details.
type Series struct {
	// Series identity.
	ID string `json:"id"`
	// Series name.
	// May include reboot qualifiers (e.g., "The Twilight Zone (2019)").
	// Currently derived from the mp4 moov.udta.meta.ilst.tvsh.data atom.
	Name string `json:"name"`
	// Sortable name (optional).
	// Omits leading articles such as "The", "A", or "An".
	// Currently derived from the mp4 moov.udta.meta.ilst.sosn.data atom.
	SortName *string `json:"sortName"`
	// Series image (optional).
	// NYI.
	// Base64 encoded JPEG.
	// Downsampled per geometry (if specified).
	Artwork *string `json:"artwork"`
	// List of episodes.
	Episodes []*Episode `json:"episodes"`
}

type SeriesFilter struct {
	ID   *string `json:"id"`
	Name *string `json:"name"`
}

// Video details.
type Video struct {
	// Video identity.
	// Currently a hash of title + releaseYear.
	ID string `json:"id"`
	// Title, in en-US, without cut or year parenthetical qualifiers.
	// Currently derived from the mp4 moov.udta.meta.ilst.©nam.data atom.
	Title string `json:"title"`
	// Sortable title (optional).
	// Omits leading articles such as "The", "A", or "An".
	// Destyleized and normalized (i.e., "Se7en" => "Seven").
	// Normalized to first in the series (i.e., "Fast & Furious 2").
	// Includes explicit episode arabic-number for sequels (as roman numerals are not readily sortable).
	// Currently derived from the mp4 moov.udta.meta.ilst.sonm.data atom.
	SortTitle *string `json:"sortTitle"`
	// Year of initial/theatrical release.
	// Per Gregorian calendar.
	// Required due to remake ambiguity.
	// Currently derived from the mp4 moov.udta.meta.ilst.©day.data atom.
	ReleaseYear int `json:"releaseYear"`
	// List of various renditions of this video.
	// Filter by rendition quality (if specified).
	// Null or empty list implies this video is a placeholder, and renditions are coming soon.
	Renditions []*Rendition `json:"renditions"`
	// Cover art image (optional).
	// Base64 encoded JPEG.
	// Downsampled per geometry (if specified).
	// Currently derived from the mp4 moov.udta.meta.ilst.covr.data atom.
	Artwork *string `json:"artwork"`
	// Description paragraph (optional).
	// Currently derived from the mp4 moov.udta.meta.ilst.desc.data atom.
	Description *string `json:"description"`
	// NYI
	Directors []*Contributor `json:"directors"`
	// NYI
	Writers []*Contributor `json:"writers"`
	// NYI
	Cast []*Contributor `json:"cast"`
	// Primary genre (optional).
	// Currently derived from the mp4 moov.udta.meta.ilst.©gen.data atom.
	Genre *string `json:"genre"`
	// Content advisory rating (optional).
	Rating *string `json:"rating"`
	// Rotten Tomatoes reviewer score (optional).
	Tomatometer *int `json:"tomatometer"`
	// Episodic details (optional).
	Episode *Episode `json:"episode"`
}

// Amount of time and bitrate afforded to HandBrake transcode.
type TranscodeBudget string

const (
	TranscodeBudgetSuperHq  TranscodeBudget = "Super_HQ"
	TranscodeBudgetHq       TranscodeBudget = "HQ"
	TranscodeBudgetFast     TranscodeBudget = "Fast"
	TranscodeBudgetVeryFast TranscodeBudget = "Very_Fast"
)

var AllTranscodeBudget = []TranscodeBudget{
	TranscodeBudgetSuperHq,
	TranscodeBudgetHq,
	TranscodeBudgetFast,
	TranscodeBudgetVeryFast,
}

func (e TranscodeBudget) IsValid() bool {
	switch e {
	case TranscodeBudgetSuperHq, TranscodeBudgetHq, TranscodeBudgetFast, TranscodeBudgetVeryFast:
		return true
	}
	return false
}

func (e TranscodeBudget) String() string {
	return string(e)
}

func (e *TranscodeBudget) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TranscodeBudget(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TranscodeBudget", str)
	}
	return nil
}

func (e TranscodeBudget) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type VideoCodec string

const (
	// h.265
	VideoCodecH265 VideoCodec = "h265"
	// h.264 (min-spec, default)
	VideoCodecH264 VideoCodec = "h264"
)

var AllVideoCodec = []VideoCodec{
	VideoCodecH265,
	VideoCodecH264,
}

func (e VideoCodec) IsValid() bool {
	switch e {
	case VideoCodecH265, VideoCodecH264:
		return true
	}
	return false
}

func (e VideoCodec) String() string {
	return string(e)
}

func (e *VideoCodec) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = VideoCodec(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid VideoCodec", str)
	}
	return nil
}

func (e VideoCodec) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
