// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
)

// NYI
type Contributor struct {
	Name string `json:"name"`
}

// NYI
type ContributorFilter struct {
	Name *string `json:"name"`
}

// Episode (i.e., TV Show) details.
type Episode struct {
	// Season.
	Season *Season `json:"season"`
	// Episode number, within a season.
	// Currently obtained from the mp4 moov.udta.meta.ilst.tves.data atom.
	Episode int `json:"episode"`
	// Episode ID, within a series.
	// Currently obtained from the mp4 moov.udta.meta.ilst.tven.data atom.
	EpisodeID *string `json:"episodeID"`
	// Video.
	Video *Video `json:"video"`
}

// Episode selection.
type EpisodeFilter struct {
	Episode *int `json:"episode"`
}

// Geometry selection.
type GeometryFilter struct {
	Width  *int `json:"width"`
	Height *int `json:"height"`
}

// Select a slice of identifiable objects.
type Paginate struct {
	// Maximum length of list returned (optional).
	// If omitted, return remaining objects.
	First *int `json:"first"`
	// Return objects after this identified one (optional).
	// Requires a stable list.
	After *string `json:"after"`
}

// Quality details.
type Quality struct {
	VideoCodec      VideoCodec       `json:"videoCodec"`
	Resolution      string           `json:"resolution"`
	TranscodeBudget *TranscodeBudget `json:"transcodeBudget"`
}

// Quality selection.
type QualityFilter struct {
	VideoCodec *VideoCodec `json:"videoCodec"`
	Resolution *string     `json:"resolution"`
}

// Video rendition details.
type Rendition struct {
	// Rendition identity.
	// Currently a hash of local path for idempotence.
	ID string `json:"id"`
	// Video rendition download URL.
	URL string `json:"url"`
	// Cut (optional).
	// Omit wrapping parenthesis.
	// If absent, "theatrical" is implied.
	Cut *string `json:"cut"`
	// Quality details.
	Quality *Quality `json:"quality"`
	// Length of video, in minutes.
	Duration *int `json:"duration"`
	// Is video high definition, i.e., 1080p?
	// Currently obtained from the mp4 moov.udta.meta.ilst.hdvd.data atom.
	IsHd *bool `json:"isHD"`
	// Size of the video, in bytes.
	Size int `json:"size"`
}

type Renditions struct {
	All       []*Rendition `json:"all"`
	Rendition *Rendition   `json:"rendition"`
}

// Season details.
type Season struct {
	// Series.
	Series *Series `json:"series"`
	// Season number, within a series.
	// Currently obtained from the mp4 moov.udta.meta.ilst.tvsn.data atom.
	Season int `json:"season"`
	// List of episodes in season.
	Episodes []*Episode `json:"episodes"`
	// Count of episodes in season.
	EpisodeCount int `json:"episodeCount"`
}

// Season selection.
type SeasonFilter struct {
	Season *int `json:"season"`
}

// Series details.
type Series struct {
	// Series name.
	// May include reboot qualifiers (e.g., "The Twilight Zone (2019)").
	// Currently obtained from the mp4 moov.udta.meta.ilst.tvsh.data atom.
	Name string `json:"name"`
	// Sortable name.
	// Omits leading articles such as "The", "A", or "An".
	// Currently obtained from the mp4 moov.udta.meta.ilst.sosn.data atom else derived from name.
	SortName string `json:"sortName"`
	// Series image (optional).
	// NYI.
	Artwork *Artwork `json:"artwork"`
	// List of seasons.
	Seasons []*Season `json:"seasons"`
	// List of episodes, regardless of season.
	Episodes []*Episode `json:"episodes"`
	// Count of episodes, regardless of season.
	EpisodeCount int `json:"episodeCount"`
}

// Series selection.
type SeriesFilter struct {
	Name *string `json:"name"`
}

// Video details.
type Video struct {
	// Video identity.
	// Currently a hash of title + releaseYear for idempotence.
	ID string `json:"id"`
	// Title, in en-US, without cut or year parenthetical qualifiers.
	// Currently obtained from the mp4 moov.udta.meta.ilst.©nam.data atom.
	Title string `json:"title"`
	// Sortable title.
	// Omits leading articles such as "The", "A", or "An".
	// Destyleized and normalized (e.g., "Se7en" => "Seven").
	// Normalized the series (e.g., "Fast & Furious 2").
	// Includes explicit episode arabic-number for sequels (as roman numerals are not readily sortable).
	// Currently obtained from the mp4 moov.udta.meta.ilst.sonm.data atom else derived from title.
	SortTitle string `json:"sortTitle"`
	// Year of initial/theatrical release.
	// Per Gregorian calendar.
	// Required due to remake ambiguity.
	// Currently obtained from the mp4 moov.udta.meta.ilst.©day.data atom.
	ReleaseYear int `json:"releaseYear"`
	// List of various renditions of this video.
	// Filter by rendition quality (if specified).
	// Null or empty list implies this video is a placeholder, and renditions are coming soon.
	Renditions *Renditions `json:"renditions"`
	// Cover art image (optional).
	// Currently obtained from the mp4 moov.udta.meta.ilst.covr.data atom.
	Artwork *Artwork `json:"artwork"`
	// Description paragraph (optional).
	// Currently obtained from the mp4 moov.udta.meta.ilst.desc.data atom.
	Description *string `json:"description"`
	// NYI
	Directors []*Contributor `json:"directors"`
	// NYI
	Writers []*Contributor `json:"writers"`
	// NYI
	Cast []*Contributor `json:"cast"`
	// Primary genre (optional).
	// Currently obtained from the mp4 moov.udta.meta.ilst.©gen.data atom.
	Genre *string `json:"genre"`
	// Content advisory rating (optional).
	ContentRating *string `json:"contentRating"`
	// Rotten Tomatoes reviewer score (optional).
	Tomatometer *int `json:"tomatometer"`
	// Episodic details (optional).
	Episode *Episode `json:"episode"`
}

// Amount of time and bitrate afforded to HandBrake transcode.
type TranscodeBudget string

const (
	TranscodeBudgetSuperHq  TranscodeBudget = "Super_HQ"
	TranscodeBudgetHq       TranscodeBudget = "HQ"
	TranscodeBudgetFast     TranscodeBudget = "Fast"
	TranscodeBudgetVeryFast TranscodeBudget = "Very_Fast"
)

var AllTranscodeBudget = []TranscodeBudget{
	TranscodeBudgetSuperHq,
	TranscodeBudgetHq,
	TranscodeBudgetFast,
	TranscodeBudgetVeryFast,
}

func (e TranscodeBudget) IsValid() bool {
	switch e {
	case TranscodeBudgetSuperHq, TranscodeBudgetHq, TranscodeBudgetFast, TranscodeBudgetVeryFast:
		return true
	}
	return false
}

func (e TranscodeBudget) String() string {
	return string(e)
}

func (e *TranscodeBudget) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TranscodeBudget(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TranscodeBudget", str)
	}
	return nil
}

func (e TranscodeBudget) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Video codec.
// Useful for playback hardware limitations.
type VideoCodec string

const (
	// h.265
	VideoCodecH265 VideoCodec = "h265"
	// h.264 (min-spec, default)
	VideoCodecH264 VideoCodec = "h264"
)

var AllVideoCodec = []VideoCodec{
	VideoCodecH265,
	VideoCodecH264,
}

func (e VideoCodec) IsValid() bool {
	switch e {
	case VideoCodecH265, VideoCodecH264:
		return true
	}
	return false
}

func (e VideoCodec) String() string {
	return string(e)
}

func (e *VideoCodec) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = VideoCodec(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid VideoCodec", str)
	}
	return nil
}

func (e VideoCodec) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
